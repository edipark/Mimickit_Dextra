import numpy as np
import torch
from torch.utils.data import Dataset
import scipy.io


class BCDataset(Dataset):
    """
    Dataset for Behavior Cloning
    Loads data from .npz files
    """
    def __init__(self, data_path, transform=None):
        """
        Args:
            data_path: Path to .npz file (generated by rollout_clip.py)
            transform: Optional transform to be applied on a sample
        """
        self.data_path = data_path
        self.transform = transform
        
        # Load data from .npz file
        self.data = self._load_npz_data(data_path)
        
        # Extract inputs (obs) and outputs (actions)
        # rollout_clip.py가 생성하는 형식: obs, actions
        self.inputs = self.data['obs']  # Shape: (N, obs_dim)
        self.outputs = self.data['actions']  # Shape: (N, act_dim)
        
        # TODO: 전처리 (Preprocessing) 구현
        # 
        # 전처리 예시:
        # 
        # 1. 정규화 (Normalization)
        #    self.inputs = (self.inputs - self.inputs.mean(axis=0)) / (self.inputs.std(axis=0) + 1e-8)
        #    self.outputs = (self.outputs - self.outputs.mean(axis=0)) / (self.outputs.std(axis=0) + 1e-8)
        #
        # 2. Min-Max 스케일링
        #    self.inputs = (self.inputs - self.inputs.min(axis=0)) / (self.inputs.max(axis=0) - self.inputs.min(axis=0) + 1e-8)
        #
        # 3. 특징 엔지니어링
        #    - 추가 특징 생성
        #    - 특징 선택
        #
        # 4. 데이터 증강 (Data Augmentation)
        #    - 노이즈 추가
        #    - 회전, 변환 등
        
        # Convert to tensors
        self.inputs = torch.FloatTensor(self.inputs)
        self.outputs = torch.FloatTensor(self.outputs)
        
        print(f"Loaded dataset: {len(self.inputs)} samples")
        print(f"Input shape: {self.inputs.shape}")
        print(f"Output shape: {self.outputs.shape}")
    
    def _load_npz_data(self, file_path):
        """
        Load data from .npz file (generated by rollout_clip.py)
        
        Args:
            file_path: Path to .npz file
        
        Returns:
            Dictionary containing loaded data with keys:
            - 'obs': numpy array of shape (N, obs_dim) - observations
            - 'actions': numpy array of shape (N, act_dim) - actions
            - 'episodes': number of episodes
            - 'episode_length': length of each episode
            - 'obs_indices': indices of observable states (if specified)
        """
        # numpy.load를 사용하여 .npz 파일 로드
        data = np.load(file_path, allow_pickle=True)
        
        # rollout_clip.py가 생성하는 형식:
        # - obs: (E * L, obs_dim) - flattened observations
        # - actions: (E * L, act_dim) - flattened actions
        # - episodes: number of episodes (E)
        # - episode_length: length of each episode (L)
        # - obs_indices: observable state indices (optional)
        
        result = {
            'obs': data['obs'],
            'actions': data['actions'],
        }
        
        # Optional fields
        if 'episodes' in data:
            result['episodes'] = data['episodes'].item() if hasattr(data['episodes'], 'item') else data['episodes']
        if 'episode_length' in data:
            result['episode_length'] = data['episode_length'].item() if hasattr(data['episode_length'], 'item') else data['episode_length']
        if 'obs_indices' in data:
            result['obs_indices'] = data['obs_indices']
        
        return result
    
    def __len__(self):
        return len(self.inputs)
    
    def __getitem__(self, idx):
        """
        Get a sample from the dataset
        
        Args:
            idx: Index of the sample
        
        Returns:
            Tuple of (input, output)
        """
        sample_input = self.inputs[idx]
        sample_output = self.outputs[idx]
        
        if self.transform:
            sample_input = self.transform(sample_input)
            sample_output = self.transform(sample_output)
        
        return sample_input, sample_output

